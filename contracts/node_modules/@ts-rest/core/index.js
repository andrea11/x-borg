const isAppRoute = (obj) => {
    return (obj === null || obj === void 0 ? void 0 : obj.method) !== undefined;
};
const initTsRest = () => initContract();
const initContract = () => {
    return {
        router: (args) => args,
        query: (args) => args,
        mutation: (args) => args,
        response: () => undefined,
        body: () => undefined,
    };
};

const insertParamsIntoPath = ({ path, params, }) => {
    return path
        .replace(/:([^/]+)/g, (_, p) => {
        return (params === null || params === void 0 ? void 0 : params[p]) || '';
    })
        .replace(/\/\//g, '/');
};

const convertQueryParamsToUrlString = (query, json = false) => {
    const queryString = json
        ? encodeQueryParamsJson(query)
        : encodeQueryParams(query);
    return (queryString === null || queryString === void 0 ? void 0 : queryString.length) > 0 ? '?' + queryString : '';
};
const encodeQueryParamsJson = (query) => {
    if (!query) {
        return '';
    }
    return Object.entries(query)
        .map(([key, value]) => {
        let encodedValue;
        if (typeof value === 'string' &&
            !['true', 'false', 'null'].includes(value.trim()) &&
            isNaN(Number(value))) {
            encodedValue = value;
        }
        else {
            encodedValue = JSON.stringify(value);
        }
        return `${encodeURIComponent(key)}=${encodeURIComponent(encodedValue)}`;
    })
        .join('&');
};
const encodeQueryParams = (query) => {
    if (!query) {
        return '';
    }
    return (Object.keys(query)
        .flatMap((key) => tokeniseValue(key, query[key]))
        .map((pair) => {
        const [key, ...rhs] = pair.split('=');
        return `${encodeURIComponent(key)}=${rhs
            .map(encodeURIComponent)
            .join('=')}`;
    })
        .join('&'));
};
const tokeniseValue = (key, value) => {
    if (Array.isArray(value)) {
        return value.flatMap((v, idx) => tokeniseValue(`${key}[${idx}]`, v));
    }
    if (value instanceof Date) {
        return [`${key}=${value.toISOString()}`];
    }
    if (value === null) {
        return [`${key}=`];
    }
    if (value === undefined) {
        return [];
    }
    if (typeof value === 'object') {
        return Object.keys(value).flatMap((k) =>
        tokeniseValue(`${key}[${k}]`, value[k]));
    }
    return [`${key}=${value}`];
};
const parseJsonQueryObject = (query) => {
    return Object.fromEntries(Object.entries(query).map(([key, value]) => {
        let parsedValue;
        try {
            parsedValue = JSON.parse(value);
        }
        catch {
            parsedValue = value;
        }
        return [key, parsedValue];
    }));
};

function getRouteResponses(router) {
    return {};
}
const tsRestFetchApi = async ({ path, method, headers, body, credentials, }) => {
    const result = await fetch(path, { method, headers, body, credentials });
    const contentType = result.headers.get('content-type');
    if (contentType === null || contentType === void 0 ? void 0 : contentType.includes('application/json')) {
        return { status: result.status, body: await result.json() };
    }
    if (contentType === null || contentType === void 0 ? void 0 : contentType.includes('text/plain')) {
        return { status: result.status, body: await result.text() };
    }
    return { status: result.status, body: await result.blob() };
};
const createFormData = (body) => {
    const formData = new FormData();
    Object.entries(body).forEach(([key, value]) => {
        if (value instanceof File) {
            formData.append(key, value);
        }
        else {
            formData.append(key, JSON.stringify(value));
        }
    });
    return formData;
};
const normalizeHeaders = (headers) => {
    return Object.fromEntries(Object.entries(headers).map(([k, v]) => [k.toLowerCase(), v]));
};
const fetchApi = ({ path, clientArgs, route, body, extraInputArgs, headers, }) => {
    const apiFetcher = clientArgs.api || tsRestFetchApi;
    const combinedHeaders = {
        ...normalizeHeaders(clientArgs.baseHeaders),
        ...normalizeHeaders(headers),
    };
    Object.keys(combinedHeaders).forEach((key) => {
        if (combinedHeaders[key] === undefined) {
            delete combinedHeaders[key];
        }
    });
    if (route.method !== 'GET' && route.contentType === 'multipart/form-data') {
        return apiFetcher({
            path,
            method: route.method,
            credentials: clientArgs.credentials,
            headers: combinedHeaders,
            body: body instanceof FormData ? body : createFormData(body),
            rawBody: body,
            contentType: 'multipart/form-data',
            ...extraInputArgs,
        });
    }
    return apiFetcher({
        path,
        method: route.method,
        credentials: clientArgs.credentials,
        headers: {
            'content-type': 'application/json',
            ...combinedHeaders,
        },
        body: body !== null && body !== undefined ? JSON.stringify(body) : undefined,
        rawBody: body,
        contentType: route.method !== 'GET' ? 'application/json' : undefined,
        ...extraInputArgs,
    });
};
const getCompleteUrl = (query, baseUrl, params, route, jsonQuery) => {
    const path = insertParamsIntoPath({
        path: route.path,
        params: params,
    });
    const queryComponent = convertQueryParamsToUrlString(query, jsonQuery);
    return `${baseUrl}${path}${queryComponent}`;
};
const getRouteQuery = (route, clientArgs) => {
    return async (inputArgs) => {
        const { query, params, body, headers, ...extraInputArgs } = inputArgs || {};
        const completeUrl = getCompleteUrl(query, clientArgs.baseUrl, params, route, !!clientArgs.jsonQuery);
        return await fetchApi({
            path: completeUrl,
            clientArgs,
            route,
            body,
            extraInputArgs,
            headers: headers || {},
        });
    };
};
const initClient = (router, args) => {
    return Object.fromEntries(Object.entries(router).map(([key, subRouter]) => {
        if (isAppRoute(subRouter)) {
            return [key, getRouteQuery(subRouter, args)];
        }
        else {
            return [key, initClient(subRouter, args)];
        }
    }));
};

const isZodObject = (body) => {
    return (body === null || body === void 0 ? void 0 : body.safeParse) !== undefined;
};
const checkZodSchema = (data, schema, { passThroughExtraKeys = false } = {}) => {
    if (isZodObject(schema)) {
        const result = schema.safeParse(data);
        if (result.success) {
            return {
                success: true,
                data: passThroughExtraKeys && typeof data === 'object'
                    ? { ...data, ...result.data }
                    : result.data,
            };
        }
        return {
            success: false,
            error: result.error,
        };
    }
    return {
        success: true,
        data: data,
    };
};
const zodErrorResponse = (error) => {
    return {
        name: error.name,
        issues: error.issues,
    };
};

class ResponseValidationError extends Error {
    constructor(cause) {
        super('Response validation failed');
        this.cause = cause;
    }
}

const isAppRouteResponse = (value) => {
    return (value != null &&
        typeof value === 'object' &&
        'status' in value &&
        typeof value.status === 'number');
};
const validateResponse = ({ responseType, response, }) => {
    if (isAppRouteResponse(response)) {
        const { body } = response;
        const responseValidation = checkZodSchema(body, responseType);
        if (!responseValidation.success) {
            const { error } = responseValidation;
            throw new ResponseValidationError(error);
        }
        return {
            status: response.status,
            body: responseValidation.data,
        };
    }
    return response;
};

export { ResponseValidationError, checkZodSchema, convertQueryParamsToUrlString, encodeQueryParams, encodeQueryParamsJson, fetchApi, getCompleteUrl, getRouteQuery, getRouteResponses, initClient, initContract, initTsRest, insertParamsIntoPath, isAppRoute, isAppRouteResponse, isZodObject, parseJsonQueryObject, tsRestFetchApi, validateResponse, zodErrorResponse };
