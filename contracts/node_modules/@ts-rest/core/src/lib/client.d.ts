import { AppRoute, AppRouteMutation, AppRouter } from './dsl';
import { ParamsFromUrl } from './paths';
import { HTTPStatusCode } from './status-codes';
import { AreAllPropertiesOptional, Merge, OptionalIfAllOptional, Prettify, Without, ZodInferOrType, ZodInputOrType } from './type-utils';
type RecursiveProxyObj<T extends AppRouter, TClientArgs extends ClientArgs> = {
    [TKey in keyof T]: T[TKey] extends AppRoute ? AppRouteFunction<T[TKey], TClientArgs> : T[TKey] extends AppRouter ? RecursiveProxyObj<T[TKey], TClientArgs> : never;
};
type AppRouteMutationType<T> = ZodInputOrType<T>;
/**
 * Extract the path params from the path in the contract
 */
export type PathParamsFromUrl<T extends AppRoute> = ParamsFromUrl<T['path']> extends infer U ? U : never;
/**
 * Merge `PathParamsFromUrl<T>` with pathParams schema if it exists
 */
export type PathParamsWithCustomValidators<T extends AppRoute, TClientOrServer extends 'client' | 'server' = 'server'> = T['pathParams'] extends undefined ? PathParamsFromUrl<T> : Merge<PathParamsFromUrl<T>, TClientOrServer extends 'server' ? ZodInferOrType<T['pathParams']> : ZodInputOrType<T['pathParams']>>;
type AppRouteBodyOrFormData<T extends AppRouteMutation> = T['contentType'] extends 'multipart/form-data' ? FormData | AppRouteMutationType<T['body']> : AppRouteMutationType<T['body']>;
/**
 * Extract any extra parameters from the client args
 */
export type ExtractExtraParametersFromClientArgs<TClientArgs extends ClientArgs> = TClientArgs['api'] extends ApiFetcher ? Omit<Parameters<TClientArgs['api']>[0], keyof Parameters<ApiFetcher>[0]> : {};
type DataReturnArgsBase<TRoute extends AppRoute, TClientArgs extends ClientArgs> = {
    body: TRoute extends AppRouteMutation ? AppRouteBodyOrFormData<TRoute> : never;
    params: PathParamsFromUrl<TRoute>;
    query: 'query' extends keyof TRoute ? AppRouteMutationType<TRoute['query']> : never;
    /**
     * Additional headers to send with the request, merged over baseHeaders,
     *
     * Unset a header by setting it to undefined
     */
    headers?: Record<string, string>;
} & ExtractExtraParametersFromClientArgs<TClientArgs>;
type DataReturnArgs<TRoute extends AppRoute, TClientArgs extends ClientArgs> = OptionalIfAllOptional<DataReturnArgsBase<TRoute, TClientArgs>>;
export type ApiRouteResponse<T> = {
    [K in keyof T]: {
        status: K;
        body: ZodInferOrType<T[K]>;
    };
}[keyof T] | {
    status: Exclude<HTTPStatusCode, keyof T>;
    body: unknown;
};
/**
 * @deprecated Only safe to use on the client-side. Use `ServerInferResponses`/`ClientInferResponses` instead.
 */
export type ApiResponseForRoute<T extends AppRoute> = ApiRouteResponse<T['responses']>;
/**
 * @deprecated Only safe to use on the client-side. Use `ServerInferResponses`/`ClientInferResponses` instead.
 */
export declare function getRouteResponses<T extends AppRouter>(router: T): { [K in keyof T]: T[K] extends AppRoute ? ApiResponseForRoute<T[K]> : "not a route"; };
/**
 * Returned from a mutation or query call
 */
export type AppRouteFunction<TRoute extends AppRoute, TClientArgs extends ClientArgs> = AreAllPropertiesOptional<Without<DataReturnArgs<TRoute, TClientArgs>, never>> extends true ? (args?: Prettify<Without<DataReturnArgs<TRoute, TClientArgs>, never>>) => Promise<Prettify<ApiRouteResponse<TRoute['responses']>>> : (args: Prettify<Without<DataReturnArgs<TRoute, TClientArgs>, never>>) => Promise<Prettify<ApiRouteResponse<TRoute['responses']>>>;
export interface ClientArgs {
    baseUrl: string;
    baseHeaders: Record<string, string>;
    api?: ApiFetcher;
    credentials?: RequestCredentials;
    jsonQuery?: boolean;
}
export type ApiFetcherArgs = {
    path: string;
    method: string;
    headers: Record<string, string>;
    body: FormData | string | null | undefined;
    rawBody: unknown;
    contentType: AppRouteMutation['contentType'];
    credentials?: RequestCredentials;
};
export type ApiFetcher = (args: ApiFetcherArgs) => Promise<{
    status: number;
    body: unknown;
}>;
/**
 * Default fetch api implementation:
 *
 * Can be used as a reference for implementing your own fetcher,
 * or used in the "api" field of ClientArgs to allow you to hook
 * into the request to run custom logic
 */
export declare const tsRestFetchApi: ApiFetcher;
export declare const fetchApi: ({ path, clientArgs, route, body, extraInputArgs, headers, }: {
    path: string;
    clientArgs: ClientArgs;
    route: AppRoute;
    body: unknown;
    extraInputArgs: Record<string, unknown>;
    headers: Record<string, string | undefined>;
}) => Promise<{
    status: number;
    body: unknown;
}>;
/**
 * @hidden
 */
export declare const getCompleteUrl: (query: unknown, baseUrl: string, params: unknown, route: AppRoute, jsonQuery: boolean) => string;
export declare const getRouteQuery: <TAppRoute extends AppRoute>(route: TAppRoute, clientArgs: ClientArgs) => (inputArgs?: DataReturnArgs<any, ClientArgs>) => Promise<{
    status: number;
    body: unknown;
}>;
export type InitClientReturn<T extends AppRouter, TClientArgs extends ClientArgs> = RecursiveProxyObj<T, TClientArgs>;
export declare const initClient: <T extends AppRouter, TClientArgs extends ClientArgs>(router: T, args: TClientArgs) => RecursiveProxyObj<T, TClientArgs>;
export {};
